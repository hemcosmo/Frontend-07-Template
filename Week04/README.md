# 字符串分析算法

> 简单 -> 难

- 字典树 高频字符串处理 搜索关键词 完全匹配
  - 大量高重复字符串的存储和分析
- KMP 部分匹配 复杂度 O(m+n)
  - 在长字符串里找模式
- Wildcard ? \* 弱版正则 贪心算法
  - 带通配符的字符串模式
- 正则 回溯 终极版本
  - 字符串通用模式匹配
- 有限状态机 可以加入代码的正则
  - 通用的字符串分析
- LL LR R > L
  - 字符串多层结构分析

html 语法分析 stack 处理 LR(0)

## 字典树 trie

prefix tree(前缀树)

哈希树的一种特例

best data structure to store(string) : map or object

字典序

## KMP

字符串模式匹配算法

公共前后缀 index 自重复行为 去头 -> 找公共最长子串 -> 跳转表格(前面有几个匹配)

原串 pattern 串

3 个步骤 两个指针

> 先判断指针分别指向位置的值是否相等
>
> > 如果相等, 两个指针都前进一位
>
> > 如果不相等, 看记录匹配个数的指针是否大于 0
> >
> > > 如果大于 0 就把跳转表格中该指针对应的值给到它(实则既是 pattern 串中某一个片段公共部分的个数, 又是下一次匹配开始的下标, 也是优化的部分, 避免重复匹配)
> >
> > 否则, 指向原串的指针前进一位
>
> 直至原串遍历结束为止

BF 算法(暴力) brute-force O(mn)

## Wildcard

通配符 \* ?
简化
最后一个\*尽可能多匹配 之前的所有\*尽量少的匹配
\*cd -> 类似 kmp 算法 pattern 为 cd
去掉? 即是若干个 kmp
