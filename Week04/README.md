# 字符串分析算法

- 字典树

  - 大量高重复字符串的存储和分析

- KMP

  - 在长字符串里找模式

- Wildcard

  - 带通配符的字符串模式

- 正则

  - 字符串通用模式匹配

- 有限状态机

  - 通用的字符串分析

- LL LR

  - 字符串多层结构分析

## Trie(prefix tree)

- 多叉树

- 哈希表的一种特例

1. 处理高频字符串(匹配搜索关键字)

1.1 树根据字符串从已知的公共部分伸展开(联想在搜索引擎输入关键词时的场景)

2. 编辑器自动补全, 自动提示感觉也有想通之处

- 空间换时间的一种方案

  - 公共枝干越少, 长度越长, 就把树撑的越开, 就越占地方, 但是却很显眼

## KMP(Knuth–Morris–Pratt)

- 复杂度

`time` O(n+m) = O(n)

`space` O(m)

- 关键词

跳转表格

- 个人拙见

相较于 Brute-force 算法(最坏情况下 O(nm)), kmp 算法对匹配串中的相同的部分做了优化, 避免了重复匹配. 优化的形式便是用到了跳转表格, 每个匹配串中的字符都对应有一个计数标识, 对比用前后缀的方式去理解, 其实相同的部分肉眼可见, 记录的数字是指代对应字符之前有多少个公共的字符. 感觉有点动态规划的意思, 为公共部分作出了类似缓存的策略.

- 核心步骤

> 先判断指针分别指向位置的值是否相等
>
> > 如果相等, 两个指针都前进一位
> >
> > 如果不相等, 看记录匹配个数的指针是否大于 0
> >
> > > 如果大于 0 就把跳转表格中该指针对应的值给到它(实则既是 pattern 串中某一个片段公共部分的个数, 又是下一次匹配开始的下标)
> > >
> > > 否则, 指向原串的指针前进一位
>
> 直至匹配串或原串遍历结束为止

## Wildcard

- usage

windows command-line interface

- 关键词

完全匹配

`*` 匹配 0 个或多个字符(对应正则中的`.*`)

`?` 匹配 **1** 个字符(包括空格)

- 实现思路

前面的`*`尽可能少匹配, 最后的`*`尽可能多的去匹配

1. 先对匹配串中的`*`个数做记录

1. 把匹配串按照第一个和最后一个`*`(条件存在的情况下)做切割, 分成三部分

1. 首先对第一个`*`前的字符串进行匹配, 存在`?`或者不存在的情况下对应的字符都能匹配就继续进行

1. 中间的部分通过`*`进行切割到最后一个`*`之前为止, 省略`*`进行逐个匹配, 并将终止的位置进行记录

1. 最后对剩余部分从后往前的进行匹配

1. 产生结果
